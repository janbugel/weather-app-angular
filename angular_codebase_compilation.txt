
--- index.html ---
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>weather app</title>
    <base href="/" />

    <meta name="viewport" content="width=device-width, initial-scale=1" />

    <!-- Add Roboto font -->
    <link
      href="https://fonts.googleapis.com/css?family=Roboto:300,400,500&display=swap"
      rel="stylesheet"
    />

    <!-- Add icon library for any icons you may use -->
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.1/css/all.min.css"
    />
  </head>
  <body>
    <app-root></app-root>
  </body>
</html>



--- main.ts ---
import { platformBrowserDynamic } from '@angular/platform-browser-dynamic';

import { AppModule } from './app/app.module';

platformBrowserDynamic()
  .bootstrapModule(AppModule)
  .catch((err) => console.error(err));



--- openmeteoHistorical.ts ---
import { fetchWeatherApi } from 'openmeteo';
	
const params = {
	"latitude": 51.5085,
	"longitude": -0.1257,
	"start_date": "2024-02-23",
	"end_date": "2024-03-08",
	"hourly": "temperature_2m"
};
const url = "https://archive-api.open-meteo.com/v1/archive";
const responses = await fetchWeatherApi(url, params);

// Helper function to form time ranges
const range = (start: number, stop: number, step: number) =>
	Array.from({ length: (stop - start) / step }, (_, i) => start + i * step);

// Process first location. Add a for-loop for multiple locations or weather models
const response = responses[0];

// Attributes for timezone and location
const utcOffsetSeconds = response.utcOffsetSeconds();
const timezone = response.timezone();
const timezoneAbbreviation = response.timezoneAbbreviation();
const latitude = response.latitude();
const longitude = response.longitude();

const hourly = response.hourly()!;

// Note: The order of weather variables in the URL query and the indices below need to match!
const weatherData = {

	hourly: {
		time: range(Number(hourly.time()), Number(hourly.timeEnd()), hourly.interval()).map(
			(t) => new Date((t + utcOffsetSeconds) * 1000)
		),
		temperature2m: hourly.variables(0)!.valuesArray()!,
	},

};

// `weatherData` now contains a simple structure with arrays for datetime and weather data
for (let i = 0; i < weatherData.hourly.time.length; i++) {
	console.log(
		weatherData.hourly.time[i].toISOString(),
		weatherData.hourly.temperature2m[i]
	);
}



--- styles.sass ---
.app-toolbar
  display: flex
  align-items: center
  justify-content: space-between
  .logo-container .sun-emoji
    font-size: 24px
    margin-right: 20px
  .spacer
    flex: 1
  .tabs-container .menu-icon
    margin-right: 16px
    background: none
    border: none
    display: none
  @media (max-width: 768px)
    .desktop-tabs
      display: none
    .menu-icon
      display: inline



--- openmeteoForecast.ts ---
// Install: npm install openmeteo
// Usage:

import { fetchWeatherApi } from 'openmeteo';

const params = {
  latitude: 52.52,
  longitude: 13.41,
  hourly: 'temperature_2m',
};
const url = 'https://api.open-meteo.com/v1/forecast';
const responses = await fetchWeatherApi(url, params);

// Helper function to form time ranges
const range = (start: number, stop: number, step: number) =>
  Array.from({ length: (stop - start) / step }, (_, i) => start + i * step);

// Process first location. Add a for-loop for multiple locations or weather models
const response = responses[0];

// Attributes for timezone and location
const utcOffsetSeconds = response.utcOffsetSeconds();
const timezone = response.timezone();
const timezoneAbbreviation = response.timezoneAbbreviation();
const latitude = response.latitude();
const longitude = response.longitude();

const hourly = response.hourly()!;

// Note: The order of weather variables in the URL query and the indices below need to match!
const weatherData = {
  hourly: {
    time: range(
      Number(hourly.time()),
      Number(hourly.timeEnd()),
      hourly.interval()
    ).map((t) => new Date((t + utcOffsetSeconds) * 1000)),
    temperature2m: hourly.variables(0)!.valuesArray()!,
  },
};

// `weatherData` now contains a simple structure with arrays for datetime and weather data
for (let i = 0; i < weatherData.hourly.time.length; i++) {
  console.log(
    weatherData.hourly.time[i].toISOString(),
    weatherData.hourly.temperature2m[i]
  );
}



--- app/app.component.html ---
<div class="app-header">
  <div class="tabs-container">
    <mat-tab-group class="desktop-tabs">
      <mat-tab label="Weather Table">
        <app-weather-table></app-weather-table>
      </mat-tab>
      <mat-tab label="Temperature Chart">
        <app-temperature-chart></app-temperature-chart>
      </mat-tab>
      <mat-tab label="Heat Index Calculator">
        <app-heat-index-calculator></app-heat-index-calculator>
      </mat-tab>
    </mat-tab-group>
  </div>
</div>
<router-outlet></router-outlet>


--- app/app-routing.module.ts ---
import { NgModule } from '@angular/core';
import { RouterModule, Routes } from '@angular/router';
import { TemperatureChartComponent } from './temperature-chart/temperature-chart.component';

const routes: Routes = [
  { path: 'temperature-chart', component: TemperatureChartComponent }, // Make sure this path is correct
];

@NgModule({
  imports: [RouterModule.forRoot(routes)],
  exports: [RouterModule],
})
export class AppRoutingModule {}



--- app/app.component.spec.ts ---
import { TestBed } from '@angular/core/testing';
import { RouterTestingModule } from '@angular/router/testing';
import { AppComponent } from './app.component';

describe('AppComponent', () => {
  beforeEach(async () => {
    await TestBed.configureTestingModule({
      imports: [RouterTestingModule],
      declarations: [AppComponent],
    }).compileComponents();
  });

  it('should create the app', () => {
    const fixture = TestBed.createComponent(AppComponent);
    const app = fixture.componentInstance;
    expect(app).toBeTruthy();
  });

  it(`should have as title 'weather-app-angular'`, () => {
    const fixture = TestBed.createComponent(AppComponent);
    const app = fixture.componentInstance;
    expect(app.title).toEqual('weather-app-angular');
  });

  it('should render title', () => {
    const fixture = TestBed.createComponent(AppComponent);
    fixture.detectChanges();
    const compiled = fixture.nativeElement as HTMLElement;
    expect(compiled.querySelector('h1')?.textContent).toContain(
      'Hello, weather-app-angular'
    );
  });
});



--- app/app.module.ts ---
import { NgModule } from '@angular/core';
import { BrowserModule } from '@angular/platform-browser';
import { HttpClientModule } from '@angular/common/http';
import { BrowserAnimationsModule } from '@angular/platform-browser/animations';
import { FormsModule } from '@angular/forms';

import { AppRoutingModule } from './app-routing.module';
import { AppComponent } from './app.component';
import { TabsComponent } from './tabs/tabs.component';
import { WeatherTableComponent } from './weather-table/weather-table.component';
import { TemperatureChartComponent } from './temperature-chart/temperature-chart.component';
import { HeatIndexCalculatorComponent } from './heat-index-calculator/heat-index-calculator.component';

import { NgxChartsModule } from '@swimlane/ngx-charts';

import { MatTabsModule } from '@angular/material/tabs';
import { MatTableModule } from '@angular/material/table';
import { MatPaginatorModule } from '@angular/material/paginator';
import { MatSortModule } from '@angular/material/sort';
import { MatInputModule } from '@angular/material/input';
import { MatFormFieldModule } from '@angular/material/form-field';
import { MatSelectModule } from '@angular/material/select';
import { MatButtonModule } from '@angular/material/button';
import { MatCardModule } from '@angular/material/card';
import { MatGridListModule } from '@angular/material/grid-list';
import { MatIconModule } from '@angular/material/icon';
import { MatToolbarModule } from '@angular/material/toolbar';

@NgModule({
  declarations: [
    AppComponent,
    TabsComponent,
    WeatherTableComponent,
    TemperatureChartComponent,
    HeatIndexCalculatorComponent
  ],
  imports: [
    BrowserModule,
    AppRoutingModule,
    BrowserAnimationsModule,
    HttpClientModule,
    FormsModule,
    MatTableModule,
    MatPaginatorModule,
    MatSortModule,
    MatInputModule,
    MatFormFieldModule,
    MatSelectModule,
    MatButtonModule,
    MatCardModule,
    MatGridListModule,
    MatIconModule,
    MatToolbarModule,
    MatTabsModule,
    NgxChartsModule // Ensure ngx-charts module is imported
  ],
  providers: [],
  bootstrap: [AppComponent]
})
export class AppModule {}


--- app/app.component.ts ---
import { Component } from '@angular/core';

@Component({
  selector: 'app-root',
  templateUrl: './app.component.html',
  styleUrls: ['./app.component.sass'],
})
export class AppComponent {
  title(title: any) {
    throw new Error('Method not implemented.');
  }
}


--- app/app.component.sass ---
.app-container
  display: flex
  flex-direction: column
  align-items: center
  padding: 20px

h1
  color: #1976d2
  margin-bottom: 20px



--- app/tabs/tabs.component.html ---
<mat-tab-group>
  <mat-tab label="Temperature Chart">
    <app-temperature-chart></app-temperature-chart>
  </mat-tab>
</mat-tab-group>



--- app/tabs/tabs.component.spec.ts ---
import { ComponentFixture, TestBed } from '@angular/core/testing';

import { TabsComponent } from './tabs.component';

describe('TabsComponent', () => {
  let component: TabsComponent;
  let fixture: ComponentFixture<TabsComponent>;

  beforeEach(async () => {
    await TestBed.configureTestingModule({
      declarations: [TabsComponent],
    }).compileComponents();

    fixture = TestBed.createComponent(TabsComponent);
    component = fixture.componentInstance;
    fixture.detectChanges();
  });

  it('should create', () => {
    expect(component).toBeTruthy();
  });
});



--- app/tabs/tabs.component.ts ---
import { Component } from '@angular/core';

@Component({
  selector: 'app-tabs',
  templateUrl: './tabs.component.html',
  styleUrls: ['./tabs.component.sass'],
})
export class TabsComponent {
  activeTab: any;
  constructor() {}
}



--- app/tabs/tabs.component.sass ---



--- app/weather-table/weather-table.component.spec.ts ---
import { ComponentFixture, TestBed } from '@angular/core/testing';

import { WeatherTableComponent } from './weather-table.component';

describe('WeatherTableComponent', () => {
  let component: WeatherTableComponent;
  let fixture: ComponentFixture<WeatherTableComponent>;

  beforeEach(async () => {
    await TestBed.configureTestingModule({
      declarations: [WeatherTableComponent],
    }).compileComponents();

    fixture = TestBed.createComponent(WeatherTableComponent);
    component = fixture.componentInstance;
    fixture.detectChanges();
  });

  it('should create', () => {
    expect(component).toBeTruthy();
  });
});



--- app/weather-table/weather-table.component.html ---
<!-- app/weather-table/weather-table.component.html -->
<table mat-table [dataSource]="weatherData" class="mat-elevation-z8">
  <!-- Datetime Column -->
  <ng-container matColumnDef="datetime">
    <th mat-header-cell *matHeaderCellDef>Date Time</th>
    <td mat-cell *matCellDef="let weather">{{ weather.datetime }}</td>
  </ng-container>

  <!-- Temperature Column -->
  <ng-container matColumnDef="temperature">
    <th mat-header-cell *matHeaderCellDef>Temperature (째C)</th>
    <td mat-cell *matCellDef="let weather">{{ weather.temperature }}</td>
  </ng-container>

  <!-- Humidity Column -->
  <ng-container matColumnDef="humidity">
    <th mat-header-cell *matHeaderCellDef>Humidity (%)</th>
    <td mat-cell *matCellDef="let weather">{{ weather.humidity }}</td>
  </ng-container>

  <!-- Pressure Column -->
  <ng-container matColumnDef="pressure">
    <th mat-header-cell *matHeaderCellDef>Pressure (hPa)</th>
    <td mat-cell *matCellDef="let weather">{{ weather.pressure }}</td>
  </ng-container>

  <!-- Table Rows -->
  <tr mat-header-row *matHeaderRowDef="displayedColumns"></tr>
  <tr mat-row *matRowDef="let row; columns: displayedColumns;"></tr>
</table>



--- app/weather-table/weather-table.component.sass ---
.weather-table
  max-width: 100%
  margin: auto
  border-collapse: collapse
  thead
    background-color: #1976d2
    color: white
    th
      padding: 10px
      text-align: left
  tbody tr:nth-child(even)
    background-color: #f2f2f2
  td, th
    padding: 8px
    border: 1px solid #ddd

.weather-table td
  text-align: center
  text-align: center
  font-size: 16px

// aling text on h2 title in the center
.title
  text-align: center
  padding: 10px
  margin: 10px
  font-size: 20px
  font-weight: bold
  // blue color
  color: #1976d2


--- app/weather-table/weather-table.component.ts ---
// app/weather-table/weather-table.component.ts
import { Component, OnInit } from '@angular/core';
import { ForecastService } from '../services/forecast.service';
import { HistoricalService } from '../services/historical.service';

@Component({
  selector: 'app-weather-table',
  templateUrl: './weather-table.component.html',
  styleUrls: ['./weather-table.component.sass'],
})
export class WeatherTableComponent implements OnInit {
  weatherData: any[] = [];
  displayedColumns: string[] = ['datetime', 'temperature', 'humidity', 'pressure'];
  private readonly londonLat = 51.5074;
  private readonly londonLon = -0.1278;
  private readonly endDate = new Date().toISOString().split('T')[0];
  private readonly startDate = new Date(Date.now() - 7 * 24 * 60 * 60 * 1000).toISOString().split('T')[0];

  constructor(private forecastService: ForecastService, private historicalService: HistoricalService) {}

  ngOnInit(): void {
    this.fetchData();
  }

  fetchData(): void {
    // Fetch historical data for the past week
    this.historicalService.getHistoricalWeather({
      latitude: this.londonLat,
      longitude: this.londonLon,
      start_date: this.startDate,
      end_date: this.endDate,
      hourly: 'temperature_2m,relative_humidity_2m,pressure_msl'
    }).subscribe({
      next: (historicalData) => {
        this.weatherData = this.transformWeatherData(historicalData);
      },
      error: (error) => {
        console.error('Error fetching historical data:', error);
      }
    });

    // Fetch forecast data for the next few days
    this.forecastService.getWeatherForecast(this.londonLat, this.londonLon).subscribe({
      next: (forecastData) => {
        this.weatherData.push(...this.transformWeatherData(forecastData));
      },
      error: (error) => {
        console.error('Error fetching forecast data:', error);
      }
    });
  }

  private transformWeatherData(data: any): any[] {
    return data.hourly.time.map((time: string, index: number) => ({
      datetime: new Date(time).toLocaleString(),
      temperature: data.hourly.temperature_2m[index],
      humidity: data.hourly.relative_humidity_2m[index],
      pressure: data.hourly.pressure_msl?.[index] ?? 'N/A',
    }));
  }
}



--- app/temperature-chart/temperature-chart.component.sass ---
.temperature-chart-container
  display: block
  overflow-x: hidden
  padding: 20px



--- app/temperature-chart/temperature-chart.component.ts ---
// app/temperature-chart/temperature-chart.component.ts

import { Component, OnInit, HostListener } from '@angular/core';
import { ForecastService } from '../services/forecast.service'; // Updated import statement

@Component({
  selector: 'app-temperature-chart',
  templateUrl: './temperature-chart.component.html',
  styleUrls: ['./temperature-chart.component.sass'],
})
export class TemperatureChartComponent implements OnInit {
  public temperatureData: any[] = [];
  public view: any = [innerWidth / 1.2, 400];
  public showXAxis = true;
  public showYAxis = true;
  public gradient = false;
  public showLegend = false;
  public showXAxisLabel = true;
  public xAxisLabel = 'Time';
  public showYAxisLabel = true;
  public yAxisLabel = 'Temperature (째C)';
  public timeline = true;
  public colorScheme = 'cool'; // Use predefined color schemes like 'vivid', 'natural', etc.

  constructor(private forecastService: ForecastService) {} // Updated service injection

  ngOnInit(): void {
    this.updateChartDimensions();
    this.fetchTemperatureData();
  }

  @HostListener('window:resize', ['$event'])
  onResize(event: any) {
    this.updateChartDimensions();
  }

  updateChartDimensions(): void {
    this.view = [innerWidth / 1.2, 400]; // Dynamically adjusts the chart dimensions based on the window width
  }

  fetchTemperatureData(): void {
    const lat = 51.5074; // Latitude for London
    const lon = -0.1278; // Longitude for London

    this.forecastService.getWeatherForecast(lat, lon).subscribe({
      next: (data) => {
        // Transform data for chart
        this.temperatureData = this.transformDataForChart(data);
      },
      error: (error) => {
        console.error('Error fetching temperature data:', error);
      }
    });
  }

  transformDataForChart(data: any): any[] {
    // Transform forecast data for chart
    let chartData = [];
    for (let i = 0; i < data.hourly.time.length; i++) {
      chartData.push({
        name: new Date(data.hourly.time[i]).toLocaleString(),
        value: data.hourly.temperature_2m[i]
      });
    }
    return [{ name: 'Temperature', series: chartData }];
  }
}



--- app/temperature-chart/temperature-chart.component.html ---
<!-- Add #chartContainer reference -->
<div #chartContainer *ngIf="temperatureData && temperatureData.length > 0" class="temperature-chart-container">
  <ngx-charts-line-chart
    [view]="view"
    [scheme]="colorScheme"
    [results]="temperatureData"
    [gradient]="gradient"
    [xAxis]="showXAxis"
    [yAxis]="showYAxis"
    [legend]="showLegend"
    [showXAxisLabel]="showXAxisLabel"
    [showYAxisLabel]="showYAxisLabel"
    [xAxisLabel]="xAxisLabel"
    [yAxisLabel]="yAxisLabel"
    [timeline]="timeline">
  </ngx-charts-line-chart>
</div>


--- app/temperature-chart/temperature-chart.component.spec.ts ---
import { ComponentFixture, TestBed } from '@angular/core/testing';

import { TemperatureChartComponent } from './temperature-chart.component';

describe('TemperatureChartComponent', () => {
  let component: TemperatureChartComponent;
  let fixture: ComponentFixture<TemperatureChartComponent>;

  beforeEach(async () => {
    await TestBed.configureTestingModule({
      declarations: [TemperatureChartComponent],
    }).compileComponents();

    fixture = TestBed.createComponent(TemperatureChartComponent);
    component = fixture.componentInstance;
    fixture.detectChanges();
  });

  it('should create', () => {
    expect(component).toBeTruthy();
  });
});



--- app/heat-index-calculator/heat-index-calculator.component.sass ---
.heat-index-calculator-container
  display: flex
  justify-content: center
  margin: 20px

.form-style
  display: flex
  flex-direction: column
  gap: 20px

.heat-index-result
  font-size: 20px
  text-align: center
  font-weight: bold


--- app/heat-index-calculator/heat-index-calculator.component.ts ---
import { Component } from '@angular/core';

@Component({
  selector: 'app-heat-index-calculator',
  templateUrl: './heat-index-calculator.component.html',
  styleUrls: ['./heat-index-calculator.component.sass'],
})
export class HeatIndexCalculatorComponent {
  temperature: number | null = null;
  humidity: number | null = null;
  temperatureUnit: 'C' | 'F' = 'C';
  heatIndex: number | null = null;

  calculateHeatIndex(): void {
    if (this.temperature !== null && this.humidity !== null) {
      if (this.temperatureUnit === 'F') {
        this.heatIndex = this.calculateHeatIndexFahrenheit(
          this.temperature,
          this.humidity
        );
      } else {
        // Convert Celsius to Fahrenheit for calculation
        const tempInFahrenheit = this.convertCelsiusToFahrenheit(
          this.temperature
        );
        const heatIndexFahrenheit = this.calculateHeatIndexFahrenheit(
          tempInFahrenheit,
          this.humidity
        );
        // Convert back to Celsius for the result
        this.heatIndex = this.convertFahrenheitToCelsius(heatIndexFahrenheit);
      }
    }
  }

  private calculateHeatIndexFahrenheit(temp: number, humidity: number): number {
    // Enhanced Heat Index formula using the provided files and logic
    if (temp < 80) {
      return temp;
    }
    let heatIndex =
      -42.379 +
      2.04901523 * temp +
      10.14333127 * humidity -
      0.22475541 * temp * humidity -
      0.00683783 * temp ** 2 -
      0.05481717 * humidity ** 2 +
      0.00122874 * temp ** 2 * humidity +
      0.00085282 * temp * humidity ** 2 -
      0.00000199 * temp ** 2 * humidity ** 2;
    return Math.round(heatIndex * 10) / 10; // Rounded to one decimal place
  }

  private convertCelsiusToFahrenheit(celsius: number): number {
    return (celsius * 9) / 5 + 32;
  }

  private convertFahrenheitToCelsius(fahrenheit: number): number {
    return ((fahrenheit - 32) * 5) / 9;
  }
}



--- app/heat-index-calculator/heat-index-calculator.component.html ---
<div class="heat-index-calculator-container">
  <mat-card class="heat-index-card">
    <mat-card-header>
    </mat-card-header>
    <mat-card-content>
      <form (ngSubmit)="calculateHeatIndex()" class="form-style">
        <mat-form-field appearance="fill">
          <mat-label>Temperature</mat-label>
          <input
            matInput
            type="number"
            [(ngModel)]="temperature"
            name="temperature"
            required
          />
        </mat-form-field>
        <mat-form-field appearance="fill">
          <mat-label>Temperature Unit</mat-label>
          <mat-select [(ngModel)]="temperatureUnit" name="temperatureUnit">
            <mat-option value="C">째C</mat-option>
            <mat-option value="F">째F</mat-option>
          </mat-select>
        </mat-form-field>
        <mat-form-field appearance="fill">
          <mat-label>Relative Humidity (%)</mat-label>
          <input
            matInput
            type="number"
            [(ngModel)]="humidity"
            name="humidity"
            required
          />
        </mat-form-field>
        <button mat-raised-button color="primary" type="submit">
          Calculate
        </button>
      </form>
    </mat-card-content>
    <mat-card-actions *ngIf="heatIndex !== null">
      <p class="heat-index-result">
        Heat Index: {{ heatIndex | number : "1.0-1" }} {{ temperatureUnit }}
      </p>
    </mat-card-actions>
  </mat-card>
</div>



--- app/heat-index-calculator/heat-index-calculator.component.spec.ts ---
import { ComponentFixture, TestBed } from '@angular/core/testing';

import { HeatIndexCalculatorComponent } from './heat-index-calculator.component';

describe('HeatIndexCalculatorComponent', () => {
  let component: HeatIndexCalculatorComponent;
  let fixture: ComponentFixture<HeatIndexCalculatorComponent>;

  beforeEach(async () => {
    await TestBed.configureTestingModule({
      declarations: [HeatIndexCalculatorComponent],
    }).compileComponents();

    fixture = TestBed.createComponent(HeatIndexCalculatorComponent);
    component = fixture.componentInstance;
    fixture.detectChanges();
  });

  it('should create', () => {
    expect(component).toBeTruthy();
  });
});



--- app/services/forecast.service.ts ---
// app/services/forecast.service.ts
import { Injectable } from '@angular/core';
import { HttpClient } from '@angular/common/http';
import { Observable } from 'rxjs';

@Injectable({
  providedIn: 'root'
})
export class ForecastService {
  private baseUrl = 'https://api.open-meteo.com/v1/forecast';

  constructor(private http: HttpClient) {}

  getWeatherForecast(latitude: number, longitude: number): Observable<any> {
    const params = {
      latitude: latitude,
      longitude: longitude,
      hourly: 'temperature_2m,relative_humidity_2m,pressure_msl'
    };
    return this.http.get(this.baseUrl, { params });
  }
}

/* rewrite this file with full api logic like this

// Install: npm install openmeteo
// Usage:

import { fetchWeatherApi } from 'openmeteo';

const params = {
  latitude: 52.52,
  longitude: 13.41,
  hourly: 'temperature_2m',
};
const url = 'https://api.open-meteo.com/v1/forecast';
const responses = await fetchWeatherApi(url, params);

// Helper function to form time ranges
const range = (start: number, stop: number, step: number) =>
  Array.from({ length: (stop - start) / step }, (_, i) => start + i * step);

// Process first location. Add a for-loop for multiple locations or weather models
const response = responses[0];

// Attributes for timezone and location
const utcOffsetSeconds = response.utcOffsetSeconds();
const timezone = response.timezone();
const timezoneAbbreviation = response.timezoneAbbreviation();
const latitude = response.latitude();
const longitude = response.longitude();

const hourly = response.hourly()!;

// Note: The order of weather variables in the URL query and the indices below need to match!
const weatherData = {
  hourly: {
    time: range(
      Number(hourly.time()),
      Number(hourly.timeEnd()),
      hourly.interval()
    ).map((t) => new Date((t + utcOffsetSeconds) * 1000)),
    temperature2m: hourly.variables(0)!.valuesArray()!,
  },
};

// `weatherData` now contains a simple structure with arrays for datetime and weather data
for (let i = 0; i < weatherData.hourly.time.length; i++) {
  console.log(
    weatherData.hourly.time[i].toISOString(),
    weatherData.hourly.temperature2m[i]
  );
}
*/


--- app/services/historical.service.spec.ts ---
import { TestBed } from '@angular/core/testing';

import { HistoricalService } from './historical.service';

describe('HistoricalService', () => {
  let service: HistoricalService;

  beforeEach(() => {
    TestBed.configureTestingModule({});
    service = TestBed.inject(HistoricalService);
  });

  it('should be created', () => {
    expect(service).toBeTruthy();
  });
});



--- app/services/forecast.service.spec.ts ---
import { TestBed } from '@angular/core/testing';

import { ForecastService } from './forecast.service';

describe('ForecastService', () => {
  let service: ForecastService;

  beforeEach(() => {
    TestBed.configureTestingModule({});
    service = TestBed.inject(ForecastService);
  });

  it('should be created', () => {
    expect(service).toBeTruthy();
  });
});



--- app/services/historical.service.ts ---
// app/services/historical.service.ts
import { Injectable } from '@angular/core';
import { HttpClient } from '@angular/common/http';
import { Observable } from 'rxjs';

@Injectable({
  providedIn: 'root'
})
export class HistoricalService {
  private baseUrl = 'https://archive-api.open-meteo.com/v1/archive';

  constructor(private http: HttpClient) {}

  getHistoricalWeather(params: any): Observable<any> {
    return this.http.get(this.baseUrl, { params });
  }
}

/* rewrite this file with full api logic like this

import { fetchWeatherApi } from 'openmeteo';
	
const params = {
	"latitude": 51.5085,
	"longitude": -0.1257,
	"start_date": "2024-02-23",
	"end_date": "2024-03-08",
	"hourly": "temperature_2m"
};
const url = "https://archive-api.open-meteo.com/v1/archive";
const responses = await fetchWeatherApi(url, params);

// Helper function to form time ranges
const range = (start: number, stop: number, step: number) =>
	Array.from({ length: (stop - start) / step }, (_, i) => start + i * step);

// Process first location. Add a for-loop for multiple locations or weather models
const response = responses[0];

// Attributes for timezone and location
const utcOffsetSeconds = response.utcOffsetSeconds();
const timezone = response.timezone();
const timezoneAbbreviation = response.timezoneAbbreviation();
const latitude = response.latitude();
const longitude = response.longitude();

const hourly = response.hourly()!;

// Note: The order of weather variables in the URL query and the indices below need to match!
const weatherData = {

	hourly: {
		time: range(Number(hourly.time()), Number(hourly.timeEnd()), hourly.interval()).map(
			(t) => new Date((t + utcOffsetSeconds) * 1000)
		),
		temperature2m: hourly.variables(0)!.valuesArray()!,
	},

};

// `weatherData` now contains a simple structure with arrays for datetime and weather data
for (let i = 0; i < weatherData.hourly.time.length; i++) {
	console.log(
		weatherData.hourly.time[i].toISOString(),
		weatherData.hourly.temperature2m[i]
	);
}
*/


--- assets/.gitkeep ---


